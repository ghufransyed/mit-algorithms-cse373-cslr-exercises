2.1-1
31 41 59 26 41 58 ->
31
31 41
31 41 59
31 41 59 26
31 41 59 59
31 41 41 59
31 31 41 59
26 31 41 59
26 31 41 59 41
26 31 41 59 59
26 31 41 41 59
26 31 41 41 59 58
26 31 41 41 59 59
26 31 41 41 58 59


2.1-2
see file in 01_ch directory

2.1-3
result <- NIL
for i <- 0 to A.length -1
    if A[i] = v
        result <- i
        return result
return result

Proof:
Initialization:
before the loop, result is NIL (the default return value)

Maintenance:
if A[i] = v, then result is assigned value of i and this is returned 
immediately
if A[i] != v, then result = NIL at the end of the loop

Termination:
When the loop terminates (when i = A.length - 1), result is returned, 
and the value of result is NIL if A[i] != v for all i

2.1-4
Input: Two n-element arrays, A and B, where each element is 0 or 1
Output: An (n+1)-element array C that contains the sum of the binary
numbers in A and B.

carry <- 0
result <- 0
C = [n+1]
for i <- n to 1
    result <- A[i] + B[i] + carry
    if result == 0
        C[i + 1] <- 0
    if result == 1
        C[i + 1] <- 1
    if result == 2
        C[i + 1] <- 0
        carry <- 1
    if result == 3
        C[i + 1] <- 1
        carry <- 1
if carry == 1
    C[i] <- 1
return result

2.2-1
n^3/1000 - 100n^2 - 100n + 3 is 
theta(n^3)

2.2-2
Selection sort
Write pseudocode for this algorithm, which is known as selection sort.

Input: Array containing n integers a_1,a_2...a_n
Output: Array containing a permutation of A, with
a'_1..a'_n $ a'_1 < a'_2 < .. < a'_n

min_value <- A[1]
for i <- 1 to n-1
    for j <- 2 to n
        if A[j] < min_value
            min_value <- A[j]
    A[i] = min_value


What loop invariant does this algorithm maintain?
Why does it need to run for only the first n^1 elements,
rather than for all n elements?

loop invariant: A[1..i] contains i elements, which are monotonically
increasing (sorted)

Initialization:
A[1..i] = A[1]
Thus A[1] is sorted (trivially)

Maintenance:
Before i is incremented, A[1..i] is sorted and contains the i smallest
elements from A. After i is incremented,
The inner loop iterates through from A[i+1] to A[n], on on exit, 
min_value contains the smallest value in A[i+1] to A[n]
A[i] is assigned the value of min_value, at which point A[i] is again
sorted and containing the i smallest elements of A

Termination
The out loop terminates when i = n-1
A[1..(n-1)] contains the n-1 smallest elements in A, and is sorted
A[n] therefore must contain the largest element of A
 A[1..n] is therefore sorted.

Give the best-case and worst-case running times of selection sort in â€š-notation.
Best-case: already sorted, theta(n^2)
Worst-case: reverse sorted, theta(n^2)

2.2-3

